import pyclaw.runclaw

from numpy import *
from numpy import linalg
import pylab
import subprocess
import unittest
import os
import inspect
import types

import lib.python.claw_solution_1d as claw_solution_1d
import lib.python.claw_solution_2d as claw_solution_2d


class ConvergenceTestError(Exception):
  """Used to catch exceptions specific to ConvergenceTest."""
  pass


class NumericalError(object):
  """Represents a numerical error over a series of (dt, dx) values.
  
  Use AddDataPoint to add information for each (dt, dx) pair.  After all data
  points have been added, PowerFit will produce a fit of the form
      error ~= scale_factor * dt**exponent.
  
  Attributes:
    name: Indicates type of error.  'L1', 'L2', or 'LInfinity'
    dt_values: dt values for each run.
    dx_values: dx values for each run.
    error_values: Value of the numerical error for each run.
    scale_factor: Generated by PowerFit, as described above.
    exponent: Generated by PowerFit, as described above.
  """
  
  def __init__(self, name):
    assert name in ('L1', 'L2', 'LInfinity')
    self.name = name
    self.dt_values = []
    self.dx_values = []
    self.error_values = []
    self.scale_factor = None
    self.exponent = None
  
  def AddDataPoint(self, dt, dx, cellwise_error):
    self.dt_values.append(dt)
    self.dx_values.append(dx)
    self.error_values.append(self._CalculateErrorValues(dx, cellwise_error))
  
  def _CalculateErrorValues(self, dx, cellwise_error):
    dv = reduce(lambda x, y: x*y, dx) if isinstance(dx, tuple) else dx
    
    if self.name == 'L1':
      return sum(abs(cellwise_error)) * dv
    elif self.name == 'L2':
      return sqrt(sum(cellwise_error**2)) * dv
    elif self.name == 'LInfinity':
      return abs(cellwise_error).max()
      
  def PowerFit(self):
    """Fits error values with a curve c*dt**exponent.

    Args:
      dt_values: Vector of dt values, parallel to error_values.
      error_values: Vector of error values.
    """
    A = vstack([ones(len(self.error_values)), log(self.dt_values)]).T
    c, exponent = linalg.lstsq(A, log(self.error_values))[0]
    self.scale_factor = exp(c)
    self.exponent = exponent

  # TODO: Pass kwargs?
  def Plot(self, style='ko'):
    if self.name == 'L1':
      legend_name = 'L^1'
    elif self.name == 'L2':
      legend_name = 'L^2'
    elif self.name == 'LInfinity':
      legend_name = 'L^\infty'

    pylab.loglog(self.dt_values, self.error_values, style,
                 label='$%s$ error' % legend_name)
                 
  def PlotDtFit(self, style='k:'):
    pylab.loglog(self.dt_values, self.scale_factor*self.dt_values**self.exponent,
                 style, label='$\sim \Delta t^{%.3f}$' % self.exponent)
    

class ConvergenceTest(unittest.TestCase):

  # These must be defined in a derived class.
  build_rundata = None
  true_solution = None
  t_final = None
  dt_values = None
  mx_min = None
  errors = None

  @classmethod
  def setUpClass(cls):
    cls.home = os.getcwd()
    path = os.path.abspath(inspect.getfile(cls))
    directory = os.path.dirname(path)
    os.chdir(directory)
    mx_values = [int(round(cls.mx_min * max(cls.dt_values) / dt)) for dt in cls.dt_values]
    cls.mx_values = array(mx_values)
    # Not the most efficient way of getting the dimension, but it works.
    cls.ndim = cls.build_rundata().clawdata.ndim

    try:
      cls.MakeXclawAndRun()
    except ConvergenceTestError as error:
      # Return home before raising error so we don't break other tests.
      os.chdir(cls.home)
      raise error
    
    cls.CalculateErrors()

  @classmethod
  def tearDownClass(cls):
    subprocess.call(['make', 'clobber'], stdout=open('/dev/null', 'w'))
    os.chdir(cls.home)
    
  @classmethod
  def _GetOutputDirectory(cls, i):
    return '_output%02d' % i    

  @classmethod
  def MakeXclawAndRun(cls):
    """Makes xclaw and runs a simulation for each dt value."""

    return_code = subprocess.call(['make', 'xclaw'])
    if return_code:
      raise ConvergenceTestError(
          'Command "make xclaw" failed with return code %d.' % return_code)
    
    rundata = cls.build_rundata()
    clawdata = rundata.clawdata
    clawdata.tfinal = cls.t_final

    for i in xrange(len(cls.dt_values)):
      clawdata.dt_initial = cls.dt_values[i]
      clawdata.mx = cls.mx_values[i]
      if cls.ndim == 2:
        clawdata.my = clawdata.mx
      rundata.write()

      # Ideally, we'd check a return code here, but I don't think runclaw
      # will return one.
      output_dir = cls._GetOutputDirectory(i)
      pyclaw.runclaw.runclaw(xclawcmd='xclaw', outdir=output_dir)
      contents = os.listdir(output_dir)
      if not ('fort.t0001' in contents and 'fort.q0001' in contents):
        raise ConvergenceTestError('Failed to produce final output')

  @classmethod
  def _GetCellwiseError(cls, solution):
    """Gets cellwise error for a ClawSolution.
    
    Args:
      solution: 1d or 2d ClawSolution
    Returns:
      error (magnitude) for each cell and solution component.  Shape is the
        same as solution.values.
    """
    
    if cls.ndim == 1:
      x_values = solution.GetCellCenters()
      true_values = zeros((solution.mx, solution.meqn))
      for ix in range(solution.mx):
        true_values[ix, :] = cls.true_solution(x_values[ix], cls.t_final)
    elif cls.ndim == 2:
      x, y = solution.GetCellCenters()
      true_values = zeros((solution.mx, solution.my, solution.meqn))
      for ix in xrange(solution.mx):
        for iy in xrange(solution.my):
          true_values[ix,iy,:] = cls.true_solution(x[ix,iy], y[ix,iy], cls.t_final)
    return abs(solution.values - true_values)

  @classmethod
  def CalculateErrors(cls):
    """Fills dictionary of numerical errors: L1, L2, and LInfinity.
    
    Call after RunSimulations.
    """
    
    cls.errors = {'L1': NumericalError('L1'),
                  'L2': NumericalError('L2'),
                  'LInfinity': NumericalError('LInfinity')}
                   
    for i in xrange(len(cls.dt_values)):
      if cls.ndim == 1:
        solution = claw_solution_1d.ClawSolution(cls._GetOutputDirectory(i))
        dx_vector = solution.dx
      elif cls.ndim == 2:
        solution = claw_solution_2d.ClawSolution(cls._GetOutputDirectory(i))
        dx_vector = (solution.dx, solution.dy)

      solution.SetFrame(1)
      cellwise_error = cls._GetCellwiseError(solution)

      for e in cls.errors.itervalues():
        e.AddDataPoint(cls.dt_values[i], dx_vector, cellwise_error)

    for e in cls.errors.itervalues():
      e.PowerFit()

  @classmethod
  def GetConvergenceOrder(cls, name):
    """Checks that an error type matches the specified convergence order.

    Args:
      name: Name of the error being specified; one of the valid names for
        NumericalError.
    Returns:
      Approximated order of convergence
    """

    error = cls.errors[name]
    return error.exponent
    

